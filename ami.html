<!--BUGS:
no funciona con un js independiente
-->
<html>
	<head>
		<title>BodyMatico.js app</title>
		<style>
		html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

		</style>
	</head>
	<body>
		<script src="csg.js"></script>
		<script src="threeCSG.js"></script>
		<script src="jquery-1.11.1.min.js"></script>
		<script src="notify.min.js"></script>
		<script src="three.min.js"></script>
		<script src="PointerLockControls.js"></script>
		<script src="interfaz.js"></script>
		<script src="Raycaster.js"></script>
		<script src="Clock.js"></script>
		<script>
		 	var pausa=false;
			var theta=0.0;
			var h=0.0;
			var Z=5;
			var zoom=75;
			var Edown=null;
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
			var hemiLightIN=true;
			var dirLightIN=true;
			var lightIN=true;
			var renderer = new THREE.WebGLRenderer();
var allies=[];
var enemies=[];

			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

var interface1=new Interfaz (camera,scene);
THREE.ImageUtils.crossOrigin = "anonymous";





			var materialArray = [];
 materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'skybox/CementaryFT.jpg' ) }));
    materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'skybox/CementaryBK.jpg' ) }));

    materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'skybox/CementaryUP.jpg' ) }));
    materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'skybox/CementaryDN.jpg' ) }));

    materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'skybox/CementaryRT.jpg' ) }));
materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'skybox/CementaryLT.jpg' ) }));
    
for (var i = 0; i < 6; i++){materialArray[i].side = THREE.BackSide;}
    var skyboxGeom = new THREE.BoxGeometry( 1000, 1000, 1000, 1, 1, 1);//era 1000
    var skybox = new THREE.Mesh( skyboxGeom, new THREE.MeshFaceMaterial(materialArray));
    scene.add(skybox);



			
			/*
			var texturePiso = THREE.ImageUtils.loadTexture('../chess.jpg');
			texturePiso.wrapS = texturePiso.wrapT = THREE.RepeatWrapping;			
			texturePiso.repeat.set( 80, 80 );
			geometry = new THREE.PlaneBufferGeometry( 1000, 1000, 1, 1 );
			material  = new THREE.MeshPhongMaterial( {combine: THREE.MixOperation, map:texturePiso, ambient: 0xffffff, specular: 0x050505 } );
			material.side = THREE.DoubleSide;
//var floor = new THREE.Mesh( geometry, material );
 var floor= getTerreno(THREE.ImageUtils.loadTexture('heightmap/map1.bmp'),material,1000,1000);
floor.rotation.x = Math.PI/2;
			floor.receiveShadow = true;
			scene.add( floor );
*/
			
	getTerreno();		


var weapon=new Arma(30,2,1);
var c = new THREE.Mesh( new THREE.BoxGeometry( 0.4, 1.5, 0.4 ), new THREE.MeshLambertMaterial({color:'red'}));
			c.position.x=15;
			c.position.z=15;
var enemy=new SerVivo (c,scene,allies,enemies);
enemy.addArma(weapon);


var cil= new THREE.Mesh( new THREE.CylinderGeometry( 0.1, 0.5,1.7 ), new THREE.MeshLambertMaterial({color:'yellow'}));
			cil.position.y=0.5;
			cil.position.z=1;
			cil.position.x=15;
			scene.add(cil);
var ally=new SerVivo (cil,scene,enemies,allies);
ally.addArma(weapon.clone());

//enemy.setDestino(new THREE.Vector3(-10,-10,-10));


var hemiLight,dirLight,light;

seHizoLaLuz();
seHizoElSol();
seHizoElFoco();
//Y vi que era bueno		

renderer.shadowMapEnabled = true;
var clock=new THREE.Clock(true);
var dt=clock.getDelta();
			var render = function () {
				requestAnimationFrame(render);				
				camera.fov = zoom;
  				camera.updateProjectionMatrix();//se necesita cada vez que se cambia el zoom
				interface1.update();
				dt=clock.getDelta();
				if(interface1.enabled()&&enemy.animar!=null){
					
					 for (var i=0; i < enemies.length; i++) { 
					 	enemies[i].animar(dt);
					 }
					 for (var i=0; i < allies.length; i++) { 
					 	allies[i].animar(dt);
					 }
				}
				renderer.render(scene, camera);

			};

			render();

function Arma(dano,rango,cadencia){
var damage=dano;
var range=rango;
var rate=cadencia;//en segundos
var time=0;
var owner=null;
this.setOwner=function(ow){
  owner=ow;
}
this.getRange=function(){
	return range;
}
this.atacar=function(enemy,dt){
	time+=dt;
	if(time>cadencia){
		//$.notify("owner: "+owner);
		enemy.setHealth(enemy.getHealth()-damage);
		
		var vector = new THREE.Vector3(0,0,1);
		var mesh=owner.getMesh();
   vector.applyQuaternion(mesh.quaternion);
var vectorInit=vector.clone().applyAxisAngle (new THREE.Vector3(1,0,0), Math.PI/4);
//dibujarLinea(mesh.position,mesh.position.clone().add(vectorInit.multiplyScalar(range)),"red");
//dibujarLinea(mesh.position,mesh.position.clone().add(vector.multiplyScalar(range)),"blue");
var plano= getPlano(mesh.position,mesh.position.clone().add(vectorInit.multiplyScalar(range)),mesh.position,mesh.position.clone().add(vector.multiplyScalar(range)));

		if(enemy.getHealth()){
			$.notify("el enemigo se quedo con "+enemy.getHealth()+" de vida",{className: 'warn' });
		}else{
			$.notify("el enemigo se murio",{className: 'warn' });
			var meshAr=cortar(enemy.getMesh(),plano);
			scene.remove(enemy.getMesh());
			explode(meshAr,plano,0.1);
			scene.add(meshAr[0]);
			scene.add(meshAr[1]);
			meshAr[0].material.transparent = true;
			enemy.setDead(meshAr);
		}
		
	}
	time=time%cadencia;
	return !enemy.getHealth();
}
this.clone=function(){
	return new Arma(damage,range,rate);
}
}


function SerVivo (o,scene,_enemies,_allies) {
	var tiempoPutrefaccion=2;
   var range=80;
   var velocity=3;
   	
   var object = o;
   var focus=null;
   var destino=null;
   var y=new THREE.Vector3( 0, 1,0);
   var allies=_allies;
   var enemies=_enemies;
   var arma=null;
   var health=100;
   scene.add(object);
   var box = new THREE.Box3().setFromObject(object);
   object.position.y=(box.max.y-box.min.y)/2;
   this.accion=null;//cada accion deberia tener una parte de actuar y otra de check;
   var vector = new THREE.Vector3( 0, 0,-1);
   vector.applyQuaternion(object.quaternion );
   var vision=new THREE.Raycaster(object.position, vector, 1, range);
   var dead=null;
   allies.splice(1,0,this);
//dibujarLinea(object.position, object.position.clone().add(vector.multiplyScalar(range)),"green");
this.addArma=function(arm){
 arma=arm;
 arma.setOwner(this);
}
this.setDead=function(o){
	dead=o;
}
this.podrirse=function(dt){
	dead[1].material.opacity=dead[1].material.opacity-0.01;
	if(dead[1].material.opacity<=0){
		scene.remove(dead[0]);
		scene.remove(dead[1]);
		allies.splice(allies.indexOf(this),1);
	}
}
this.setHealth=function(h){
	health=h;
	if(health<=0){//ha muerto
		health=0;
		this.accion=this.podrirse;
	}
}
this.getHealth=function(){
	return health;
}
this.getMesh=function(){
	return object;
}
this.setDestino=function(dest){
	destino=dest;
}
 this.estaCerca=function(ene){
	return object.position.distanceTo(ene.getMesh().position)<=range;
 }
this.dentroRangoAtaque=function(ene){
	return object.position.distanceTo(ene.getMesh().position)<=arma.getRange();
} 
this.observar=function(){
	var vector = new THREE.Vector3(0,0,-1);
	var ene=null;
	var dist=99999;
	var d;
   vector.applyQuaternion(object.quaternion );
   for (var i=0; i < enemies.length; i++) { 
 if(this.estaCerca(enemies[i])&&Math.abs(vector.angleTo(enemies[i].getMesh().position.clone().sub(object.position)))<=Math.PI/4){
	 	  d=object.position.distanceTo(enemies[i].getMesh().position);
			if(d<dist){
				ene=enemies[i];
				dist=d;
			}
		}
	}
	return ene;
}
this.animar=function(dt){
	this.accion(dt);
	}
this.idle=function(){
	var ene=this.observar();
if(ene!=null){//si encuentra un enemigo
	focus=ene;
	this.accion=this.atacar;
	return;
}
if(destino!=null){
	this.accion=this.mover;
}
}
this.accion=this.idle;
this.atacar=function(dt){
	if(focus==null){this.accion=this.idle;return;}
	if(this.dentroRangoAtaque(focus)){
		if(arma.atacar(focus,dt)){//debe decir si murio o no
			focus=null;
			destino=null;
			this.accion=this.idle;
		}
	}else{
		this.accion=this.mover;
	}
}
this.mover = function(dt) {
   	if(focus!=null){
   		if(this.dentroRangoAtaque(focus)){
			this.accion=this.atacar;
			return;
   		}else
   		if(!this.estaCerca(focus)){
   			focus=null;
   		}
   		destino=focus.getMesh().position;
   	}
	   	if(destino!=null){
	   		if(this.goTo(dt,destino)){//retorna booleano que indica si llego o no
	   			destino=null;
	   			this.accion=this.idle;
	   		}
	   	}
   	}
this.goTo=function(dt,position){
position.y=object.position.y;
object.lookAt(position);
var vector=new THREE.Vector3( 0, 0, -1 );
vector.subVectors(position,object.position);
vector.y=0;
var dist=vector.clone();
vector.normalize();
vector=vector.multiplyScalar(dt*velocity);
if(vector.length()<dist.length()){
object.position.add(vector);
return false;
}else{
object.position.add(dist);
return true;//no pasa
}
}
}
function getTerreno(img,material,width,height){
// texture used to generate "bumpiness"
	var bumpTexture = new THREE.ImageUtils.loadTexture( 'map/heightmap.png' );
	bumpTexture.wrapS = bumpTexture.wrapT = THREE.RepeatWrapping; 
	// magnitude of normal displacement
	var bumpScale   = 200.0;
	
	var oceanTexture = new THREE.ImageUtils.loadTexture( 'map/dirt-512.jpg' );
	oceanTexture.wrapS = oceanTexture.wrapT = THREE.RepeatWrapping; 
	
	var sandyTexture = new THREE.ImageUtils.loadTexture( 'map/sand-512.jpg' );
	sandyTexture.wrapS = sandyTexture.wrapT = THREE.RepeatWrapping; 
	
	var grassTexture = new THREE.ImageUtils.loadTexture( 'map/grass-512.jpg' );
	grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping; 
	
	var rockyTexture = new THREE.ImageUtils.loadTexture( 'map/rock-512.jpg' );
	rockyTexture.wrapS = rockyTexture.wrapT = THREE.RepeatWrapping; 
	
	var snowyTexture = new THREE.ImageUtils.loadTexture( 'map/snow-512.jpg' );
	snowyTexture.wrapS = snowyTexture.wrapT = THREE.RepeatWrapping;

var customUniforms = {
		bumpTexture:	{ type: "t", value: bumpTexture },
		bumpScale:	    { type: "f", value: bumpScale },
		oceanTexture:	{ type: "t", value: oceanTexture },
		sandyTexture:	{ type: "t", value: sandyTexture },
		grassTexture:	{ type: "t", value: grassTexture },
		rockyTexture:	{ type: "t", value: rockyTexture },
		snowyTexture:	{ type: "t", value: snowyTexture },
	};
var customMaterial = new THREE.ShaderMaterial( 
	{
	    uniforms: customUniforms,
		vertexShader:  
		"uniform sampler2D bumpTexture;"+
		"uniform float bumpScale;"+
		"varying float vAmount;"+
		"varying vec2 vUV;"+
		"void main(){"+
		"	vUV = uv;"+
		"	vec4 bumpData = texture2D( bumpTexture, uv );"+
		"    vAmount = bumpData.r;"+
		"    vec3 newPosition = position + normal * bumpScale * vAmount;"+
		"	gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );}",
		//document.getElementById( 'fragmentShader' ).textContent,
		fragmentShader: 
		"uniform sampler2D oceanTexture;\n"+
		"uniform sampler2D sandyTexture;\n"+
		"uniform sampler2D grassTexture;\n"+
		"uniform sampler2D rockyTexture;\n"+
		"uniform sampler2D snowyTexture;\n"+
		"varying vec2 vUV;\n"+
		"varying float vAmount;\n"+
		"void main(){\n"+ 
			"vec4 water = (smoothstep(0.01, 0.25, vAmount) - smoothstep(0.24, 0.26, vAmount)) * texture2D( oceanTexture, vUV * 10.0 );\n"+
			"vec4 sandy = (smoothstep(0.24, 0.27, vAmount) - smoothstep(0.28, 0.31, vAmount)) * texture2D( sandyTexture, vUV * 10.0 );\n"+
			"vec4 grass = (smoothstep(0.28, 0.32, vAmount) - smoothstep(0.35, 0.40, vAmount)) * texture2D( grassTexture, vUV * 20.0 );\n"+
			"vec4 rocky = (smoothstep(0.30, 0.50, vAmount) - smoothstep(0.40, 0.70, vAmount)) * texture2D( rockyTexture, vUV * 20.0 );\n"+
			"vec4 snowy = (smoothstep(0.50, 0.65, vAmount))*texture2D( snowyTexture, vUV * 10.0 );"+
			"gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0)+water+sandy+grass+rocky+snowy;\n}",

	}   );

/*"uniform sampler2D oceanTexture;\n"+
		"uniform sampler2D sandyTexture;\n"+
		"uniform sampler2D grassTexture;\n"+
		"uniform sampler2D rockyTexture;\n"+
		"uniform sampler2D snowyTexture;\n"+
		"varying vec2 vUV;\n"+
		"varying float vAmount;\n"+
		"void main(){\n"+ 
			"vec4 water = (smoothstep(0.01, 0.25, vAmount) - smoothstep(0.24, 0.26, vAmount)) * texture2D( oceanTexture, vUV * 10.0 );\n"+
			"vec4 sandy = (smoothstep(0.24, 0.27, vAmount) - smoothstep(0.28, 0.31, vAmount)) * texture2D( sandyTexture, vUV * 10.0 );\n"+
			"vec4 grass = (smoothstep(0.28, 0.32, vAmount) - smoothstep(0.35, 0.40, vAmount)) * texture2D( grassTexture, vUV * 20.0 );\n"+
			"vec4 rocky = (smoothstep(0.30, 0.50, vAmount) - smoothstep(0.40, 0.70, vAmount)) * texture2D( rockyTexture, vUV * 20.0 );\n"+
			"vec4 snowy = (smoothstep(0.50, 0.65, vAmount))*texture2D( snowyTexture, vUV * 10.0 );"+
			"gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0)+water+sandy+grass+rocky+snowy;\n}",*/

	var planeGeo = new THREE.PlaneGeometry( 1000, 1000, 100, 100 );
	var plane = new THREE.Mesh(	planeGeo, customMaterial );
	plane.rotation.x = -Math.PI / 2;
	plane.position.y = -100;
	scene.add( plane );

/*	var waterGeo = new THREE.PlaneGeometry( 1000, 1000, 1, 1 );
	var waterTex = new THREE.ImageUtils.loadTexture( 'images/water512.jpg' );
	waterTex.wrapS = waterTex.wrapT = THREE.RepeatWrapping; 
	waterTex.repeat.set(5,5);
	var waterMat = new THREE.MeshBasicMaterial( {map: waterTex, transparent:true, opacity:0.40} );
	var water = new THREE.Mesh(	planeGeo, waterMat );
	water.rotation.x = -Math.PI / 2;
	water.position.y = -50;
	scene.add( water);
*/
}
/*
function getHeightData(img,scale) {
  
 if (scale == undefined) scale=1;
  
    var canvas = document.createElement( 'canvas' );
    canvas.width = img.width;
    canvas.height = img.height;
    var context = canvas.getContext( '2d' );
 
    var size = img.width * img.height;
    var data = new Float32Array( size );
 
    context.drawImage(img,0,0);
 
    for ( var i = 0; i < size; i ++ ) {
        data[i] = 0
    }
 
    var imgd = context.getImageData(0, 0, img.width, img.height);
    var pix = imgd.data;
 
    var j=0;
    for (var i = 0; i<pix.length; i +=4) {
        var all = pix[i]+pix[i+1]+pix[i+2];
        data[j++] = all/(12*scale);
    }
     
    return data;
}

function getTerreno(img,material,width,height){
var plane;
var img = new Image();
img.onload = function () {
  
    //get height data from img
    var data = getHeightData(img);
  
    // plane
    var geometry = new THREE.PlaneGeometry(width,height,img.width,img.height);
    plane = new THREE.Mesh( geometry, material );
	     
    //set height of vertices
    for ( var i = 0; i<plane.geometry.vertices.length; i++ ) {
         plane.geometry.vertices[i].z = data[i];
    }
 $.notify(plane);
    //scene.add(plane);
   
};
// load img source
img.src = "heightmap/map1.bmp";
$.notify(plane);
return plane;
}
*/

function cross(u,v){
return new THREE.Vector3((u.y*v.z)-(u.z*v.y),
						 -((u.x*v.z)-(v.x*u.z)),
						 (u.x*v.y)-(v.x*u.y));

}
function explode(meshAr,plane,d) {
var vector = new THREE.Vector3( 0, 0, -1 );
	vector.applyQuaternion( plane.quaternion );
	meshAr[0].position.x-=d*vector.x;
	meshAr[0].position.y-=d*vector.y;
	meshAr[0].position.z-=d*vector.z;
	meshAr[1].position.x+=d*vector.x;
	meshAr[1].position.y+=d*vector.y;
	meshAr[1].position.z+=d*vector.z;
}
function cortar(mesh,plane){
var box = new THREE.Box3().setFromObject(mesh);
var tam=getDistancia(box.min.x,box.min.y,box.min.z,box.max.x,box.max.y,box.max.z);
tam*=2;
var boxPlane=new THREE.Mesh(new THREE.BoxGeometry( tam, tam, tam ),new THREE.MeshLambertMaterial({color: 'blue', wireframe:true}));

var vector = new THREE.Vector3( 0, 0,-1);
vector.applyQuaternion(plane.quaternion );
boxPlane.rotation.x=plane.rotation.x;
boxPlane.rotation.y=plane.rotation.y;
boxPlane.rotation.z=plane.rotation.z;

boxPlane.position.x=plane.position.x+(tam/2)*vector.x;
boxPlane.position.y=plane.position.y+(tam/2)*vector.y;
boxPlane.position.z=plane.position.z+(tam/2)*vector.z;

//scene.add(boxPlane);

var mesh2=mesh.clone();

mesh = (new ThreeBSP(mesh)).subtract((new ThreeBSP(boxPlane))).toMesh(mesh.material);
mesh.geometry.computeVertexNormals();

mesh2 = (new ThreeBSP(mesh2)).intersect((new ThreeBSP(boxPlane))).toMesh(mesh.material);
mesh2.geometry.computeVertexNormals();
return [mesh,mesh2];

}

function getPlano(v1i,v1f,v2i,v2f){
var geometry = new THREE.Geometry();
var mI=new THREE.Vector3((v1f.x+v1i.x)/2,(v1f.y+v1i.y)/2,(v1f.z+v1i.z)/2);
var mF=new THREE.Vector3((v2f.x+v2i.x)/2,(v2f.y+v2i.y)/2,(v2f.z+v2i.z)/2);
var m=new THREE.Vector3((mF.x+mI.x)/2,(mF.y+mI.y)/2,(mF.z+mI.z)/2);
var b=new THREE.Vector3(v2f.x-v2i.x,v2f.y-v2i.y,v2f.z-v2i.z);
var a=new THREE.Vector3(mF.x-mI.x,mF.y-mI.y,mF.z-mI.z);
var p=cross(a,b);
var plan=new THREE.Mesh(new THREE.PlaneBufferGeometry(mF.sub(mI).length(),b.length(),1,1), new THREE.MeshPhongMaterial({color:'yellow'}));

plan.material.side = THREE.DoubleSide;
plan.position.x=m.x;
plan.position.y=m.y;
plan.position.z=m.z;

var v = plan.position.clone();
v.add(p);
plan.lookAt( v );
return(plan);
}
function dibujarLinea(u,v,col){
var L = new THREE.Geometry();
    L.vertices.push(u);
    L.vertices.push(v);
scene.add(new THREE.Line(L, new THREE.LineBasicMaterial({color: col})));
}
function getDistancia(x1,y1,z1,x2,y2,z2){
return Math.sqrt(Math.pow(z2-z1,2)+Math.pow(y2-y1,2)+Math.pow(x2-x1,2));
}
function getBoundingBox(mesh){
var box = new THREE.Box3().setFromObject(mesh);
var tam=getDistancia(box.min.x,box.min.y,box.min.z,box.max.x,box.max.y,box.max.z);
tam/=Math.sqrt(2);
var boxP=new THREE.Mesh(new THREE.BoxGeometry( tam, tam, tam),new THREE.MeshLambertMaterial({color: 'blue'}));
boxP.position.x=mesh.position.x;
boxP.position.y=mesh.position.y;
boxP.position.z=mesh.position.z;
return boxP;
}
function seHizoLaLuz(){
	hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
	hemiLight.color.setHSL( 0.6, 1, 0.6 );
	hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
	hemiLight.position.set( 0, 500, 0 );
	scene.add( hemiLight );
}
function seHizoElSol(){
dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
dirLight.color.setHSL( 0.1, 1, 0.95 );
dirLight.position.set( -1, 1.75, 1 );
dirLight.position.multiplyScalar( 50 );
scene.add( dirLight );

dirLight.castShadow = true;

dirLight.shadowMapWidth = 2048;
dirLight.shadowMapHeight = 2048;

var d = 50;
dirLight.shadowCameraLeft = -d;
dirLight.shadowCameraRight = d;
dirLight.shadowCameraTop = d;
dirLight.shadowCameraBottom = -d;

dirLight.shadowCameraFar = 3500;
dirLight.shadowBias = -0.0001;
dirLight.shadowDarkness = 0.35;
}

function seHizoElFoco(){
light = new THREE.SpotLight( 0xffffff, 1 );
light.castShadow = true;
light.shadowDarkness = 1;
light.shadowCameraRight     =  10;
light.shadowCameraLeft     = -10;
light.shadowCameraTop      =  10;
light.shadowCameraBottom   = -10;
light.position.y=4;
scene.add(light);
}
function createSphere(x,y,z,color){
var sphere = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshPhongMaterial({color: color}) );
sphere.position.x=x;
sphere.position.y=y;
sphere.position.z=z;
scene.add(sphere);
}
function addTags(){
blocker = document.createElement('div');
blocker.setAttribute('id','blocker');
instructions=document.createElement('div');

instructions.setAttribute('id','instructions');
var span = document.createElement('span');
span.innerHTML="Click to play";
span.style.fontSize="40px";
var br = document.createElement('br');

blocker.style.position="absolute";
blocker.style.width="100%";
blocker.style.height="100%";
blocker.style.backgroundColor="rgba(0,0,0,0.5)";

instructions.style.width="100%";
instructions.style.height="100%";
instructions.style.display="-webkit-box";
instructions.style.display="-moz-box";
instructions.style.display="box";
instructions.style.display="box";
instructions.style.textAlign="center";
instructions.style.cursor="pointer";
instructions.setAttribute('style','-webkit-box-orient: horizontal;-moz-box-orient: horizontal;box-orient: horizontal;-webkit-box-pack: center;-moz-box-pack: center;box-pack: center;-webkit-box-align: center;-moz-box-align: center;box-align: center;');
instructions.appendChild(span);
instructions.appendChild(br);
instructions.innerHTML+="(W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)";


instructions.style.position="absolute";
instructions.style.top="50%";
instructions.style.left="50%";
instructions.style.transform="translate(-50%, -50%)";
instructions.style.color="#FFFFFF"

blocker.appendChild(instructions);
document.body.insertBefore(blocker, document.body.firstChild);
//document.getElementsByTagName("body")[0].insertBefore(blocker, document.getElementsByTagName("body")[0].firstChild);
}
function InitControls(){
var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
	if ( havePointerLock ) {
	var element = document.body;
	pointerlockchange = function ( event ) {
	if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
			controls.enable();
			blocker.style.display = 'none';
		} else {
			controls.disable();
			blocker.style.display = '-webkit-box';
			blocker.style.display = '-moz-box';
			blocker.style.display = 'box';
			blocker.style.display = '';
			}
		}
		var pointerlockerror = function ( event ) {
			blocker.style.display = '';
		}
// Hook pointer lock state change events
				document.addEventListener( 'pointerlockchange', pointerlockchange, false );
				document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
				document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
				document.addEventListener( 'pointerlockerror', pointerlockerror, false );
				document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
				document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
blocker.addEventListener( 'click', function ( event ) {
					blocker.style.display = 'none';
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
					if ( /Firefox/i.test( navigator.userAgent ) ) {
						var fullscreenchange = function ( event ) {
							if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
								document.removeEventListener( 'fullscreenchange', fullscreenchange );
								document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
								element.requestPointerLock();
							}
						}
						document.addEventListener( 'fullscreenchange', fullscreenchange, false );
						document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );
						element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
						element.requestFullscreen();
					} else {
						element.requestPointerLock();
					}
				}, false );
			} else {
				instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
			}
}

	</script>
	</body>
</html>