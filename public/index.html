<html>
	<head>
		<title>BodyMatico.js app</title>
		<style>
		html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

		</style>
	</head>
	<body>
		<script src="three.min.js"></script>
		<script src="csg.js"></script>
		<script src="threeCSG.js"></script>
		<script src="jquery-1.11.1.min.js"></script>
		<script src="notify.min.js"></script>
		<script src="PointerLockControls.js"></script>
		<script src="interfaz.js"></script>
		<script src="Raycaster.js"></script>
		<script src="Clock.js"></script>
		<script src="AmbienteMatico.js"></script>
		<script>
		 	var pausa=false;
			var theta=0.0;
			var h=0.0;
			var Z=5;
			var zoom=75;
			var Edown=null;
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
			var hemiLightIN=true;
			var dirLightIN=true;
			var lightIN=true;
			var renderer = new THREE.WebGLRenderer();
var allies=[];
var enemies=[];

			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

var interface1=new Interfaz (camera,scene);
THREE.ImageUtils.crossOrigin = "anonymous";


	var ambiente=new ambienteMatico(scene);

	interface1.setAmbiente(ambiente);
//placas tectonicas
	ambiente.addPlaca('map/dirt-512.jpg',40,10);//url de la textura, peso con respecto a la altura, numero de veces que se repite esta
	ambiente.addPlaca('map/sand-512.jpg',7.7,10);
	ambiente.addPlaca('map/grass-512.jpg',12.3,10);
	ambiente.addPlaca('map/rock-512.jpg',16.9,10);
	ambiente.addPlaca('map/snow-512.jpg',10,5);

ambiente.setDifuminado(0.1);//default es 0.02
	ambiente.setHeightMap("map/heightmap.png");
	
	ambiente.setSkybox("dawn");//era Cementary
	ambiente.setMar("map/water512.jpg");

	ambiente.generate();	


var weapon=new Arma(30,2,1);
var c = new THREE.Mesh( new THREE.BoxGeometry( 0.4, 1.5, 0.4 ), new THREE.MeshLambertMaterial({color:'red'}));
			c.position.x=15;
			c.position.z=15;
var enemy=new SerVivo (c,scene,ambiente,allies,enemies);
enemy.addArma(weapon);


var cil= new THREE.Mesh( new THREE.CylinderGeometry( 0.1, 0.5,1.7 ), new THREE.MeshLambertMaterial({color:'yellow'}));
			cil.position.y=0.5;
			cil.position.z=1;
			cil.position.x=15;
			scene.add(cil);
var ally=new SerVivo (cil,scene,ambiente,enemies,allies);
ally.addArma(weapon.clone());

var hemiLight,dirLight,light;

seHizoLaLuz();
seHizoElSol();
seHizoElFoco();
//Y vi que era bueno		

renderer.shadowMapEnabled = true;
var clock=new THREE.Clock(true);
var dt=clock.getDelta();
			var render = function () {
				requestAnimationFrame(render);				
				camera.fov = zoom;
  				camera.updateProjectionMatrix();//se necesita cada vez que se cambia el zoom
				interface1.update();
				dt=clock.getDelta();
				if(interface1.enabled()&&enemy.animar!=null){
					
					 for (var i=0; i < enemies.length; i++) { 
					 	enemies[i].animar(dt);
					 }
					 for (var i=0; i < allies.length; i++) { 
					 	allies[i].animar(dt);
					 }
				}
				renderer.render(scene, camera);

			};

			render();

function Arma(dano,rango,cadencia){
var damage=dano;
var range=rango;
var rate=cadencia;//en segundos
var time=0;
var owner=null;
this.setOwner=function(ow){
  owner=ow;
}
this.getRange=function(){
	return range;
}
this.atacar=function(enemy,dt){
	time+=dt;
	if(time>cadencia){
		enemy.setHealth(enemy.getHealth()-damage,owner);
		
		var vector = new THREE.Vector3(0,0,1);
		var mesh=owner.getMesh();
   vector.applyQuaternion(mesh.quaternion);
var vectorInit=vector.clone().applyAxisAngle (new THREE.Vector3(1,0,0), Math.PI/4);
var angle=(Math.random())*Math.PI*2;
vectorInit.applyAxisAngle (vector,angle);
//$.notify(""+vectorInit);
//dibujarLinea(mesh.position,mesh.position.clone().add(vectorInit.multiplyScalar(range)),"red");
//dibujarLinea(mesh.position,mesh.position.clone().add(vector.multiplyScalar(range)),"blue");
var plano= getPlano(mesh.position,mesh.position.clone().add(vectorInit.multiplyScalar(range)),mesh.position,mesh.position.clone().add(vector.multiplyScalar(range)));

		if(enemy.getHealth()){
			$.notify("el enemigo se quedo con "+enemy.getHealth()+" de vida",{className: 'warn' });
		}else{
			$.notify("el enemigo se murio",{className: 'warn' });
			var meshAr=cortar(enemy.getMesh(),plano);
			scene.remove(enemy.getMesh());
			explode(meshAr,plano,0.1);
			scene.add(meshAr[0]);
			scene.add(meshAr[1]);
			meshAr[0].material.transparent = true;
			enemy.setDead(meshAr);
		}
		
	}
	time=time%cadencia;
	return !enemy.getHealth();
}
this.clone=function(){
	return new Arma(damage,range,rate);
}
}
function SerVivo (o,scene,_ambiente,_enemies,_allies) {
	var tiempoPutrefaccion=2;
   var range=80;
   var velocity=3;
   var ambiente=_ambiente;
   var object = o;
   var focus=null;
   var destino=null;
   var y=new THREE.Vector3( 0, 1,0);
   var allies=_allies;
   var enemies=_enemies;
   var arma=null;
   var health=100;
   scene.add(object);
   var box = new THREE.Box3().setFromObject(object);
   var altura=(box.max.y-box.min.y)/2;
   object.position.y=altura
   this.accion=null;//cada accion deberia tener una parte de actuar y otra de check;
   var vector = new THREE.Vector3( 0, 0,-1);
   vector.applyQuaternion(object.quaternion );
   var vision=new THREE.Raycaster(object.position, vector, 1, range);
   var dead=null;
   allies.splice(1,0,this);//a√±ade
//dibujarLinea(object.position, object.position.clone().add(vector.multiplyScalar(range)),"green");
this.addArma=function(arm){
 arma=arm;
 arma.setOwner(this);
}
this.setDead=function(o){
	dead=o;
}
this.podrirse=function(dt){
	dead[1].material.opacity=dead[1].material.opacity-0.01;
	if(dead[1].material.opacity<=0){
		scene.remove(dead[0]);
		scene.remove(dead[1]);
		allies.splice(allies.indexOf(this),1);//elimina
	}
}
this.setHealth=function(h,who){
	health=h;
	if(health<=0){//ha muerto
		health=0;
		this.accion=this.podrirse;
	}else{
		if(focus==null){this.accion=this.atacar;focus=who;}
	}
}
this.getHealth=function(){
	return health;
}
this.getMesh=function(){
	return object;
}
this.setDestino=function(dest){
	destino=dest;
}
 this.estaCerca=function(ene){
	return object.position.distanceTo(ene.getMesh().position)<=range;
 }
this.dentroRangoAtaque=function(ene){
	return object.position.distanceTo(ene.getMesh().position)<=arma.getRange();
} 
this.observar=function(){
	var vector = new THREE.Vector3(0,0,-1);
	var ene=null;
	var dist=99999;
	var d;
   vector.applyQuaternion(object.quaternion );
   for (var i=0; i < enemies.length; i++) { 
 if(this.estaCerca(enemies[i])&&Math.abs(vector.angleTo(enemies[i].getMesh().position.clone().sub(object.position)))<=Math.PI/4){
	 	  d=object.position.distanceTo(enemies[i].getMesh().position);
			if(d<dist){
				ene=enemies[i];
				dist=d;
			}
		}
	}
	return ene;
}
this.animar=function(dt){
	this.accion(dt);
	}
this.idle=function(){
	var ene=this.observar();
if(ene!=null){//si encuentra un enemigo
	focus=ene;
	this.accion=this.atacar;
	return;
}
if(destino!=null){
	this.accion=this.mover;
}
}
this.accion=this.idle;
this.atacar=function(dt){
	if(focus==null){this.accion=this.idle;return;}
	if(this.dentroRangoAtaque(focus)){
		if(arma.atacar(focus,dt)){//debe decir si murio o no
			focus=null;
			destino=null;
			this.accion=this.idle;
		}
	}else{
		this.accion=this.mover;
	}
}
this.mover = function(dt) {
   	if(focus!=null){
   		if(this.dentroRangoAtaque(focus)){
			this.accion=this.atacar;
			return;
   		}else
   		if(!this.estaCerca(focus)){
   			focus=null;
   		}
   		destino=focus.getMesh().position;
   	}
	   	if(destino!=null){
	   		if(this.goTo(dt,destino)){//retorna booleano que indica si llego o no
	   			destino=null;
	   			this.accion=this.idle;
	   		}
	   	}
   	}
this.goTo=function(dt,position){
position.y=object.position.y;
object.lookAt(position);
var vector=new THREE.Vector3( 0, 0, -1 );
vector.subVectors(position,object.position);
vector.y=0;
var dist=vector.clone();
vector.normalize();
vector=vector.multiplyScalar(dt*velocity);

if(vector.length()<dist.length()){
object.position.add(vector);
object.position.y=ambiente.getYat(object.position.x,object.position.z)+altura;//+altura
return false;
}else{
object.position.add(dist);
object.position.y=ambiente.getYat(object.position.x,object.position.z)+altura;///+altura
return true;//no pasa
}
}
}
function cross(u,v){
return new THREE.Vector3((u.y*v.z)-(u.z*v.y),
						 -((u.x*v.z)-(v.x*u.z)),
						 (u.x*v.y)-(v.x*u.y));

}
function explode(meshAr,plane,d) {
var vector = new THREE.Vector3( 0, 0, -1 );
	vector.applyQuaternion( plane.quaternion );
	meshAr[0].position.x-=d*vector.x;
	meshAr[0].position.y-=d*vector.y;
	meshAr[0].position.z-=d*vector.z;
	meshAr[1].position.x+=d*vector.x;
	meshAr[1].position.y+=d*vector.y;
	meshAr[1].position.z+=d*vector.z;
}
function cortar(mesh,plane){
var box = new THREE.Box3().setFromObject(mesh);
var tam=getDistancia(box.min.x,box.min.y,box.min.z,box.max.x,box.max.y,box.max.z);
tam*=2;
var boxPlane=new THREE.Mesh(new THREE.BoxGeometry( tam, tam, tam ),new THREE.MeshLambertMaterial({color: 'blue', wireframe:true}));

var vector = new THREE.Vector3( 0, 0,-1);
vector.applyQuaternion(plane.quaternion );
boxPlane.rotation.x=plane.rotation.x;
boxPlane.rotation.y=plane.rotation.y;
boxPlane.rotation.z=plane.rotation.z;

boxPlane.position.x=plane.position.x+(tam/2)*vector.x;
boxPlane.position.y=plane.position.y+(tam/2)*vector.y;
boxPlane.position.z=plane.position.z+(tam/2)*vector.z;

//scene.add(boxPlane);

var mesh2=mesh.clone();

mesh = (new ThreeBSP(mesh)).subtract((new ThreeBSP(boxPlane))).toMesh(mesh.material);
mesh.geometry.computeVertexNormals();

mesh2 = (new ThreeBSP(mesh2)).intersect((new ThreeBSP(boxPlane))).toMesh(mesh.material);
mesh2.geometry.computeVertexNormals();
return [mesh,mesh2];

}

function getPlano(v1i,v1f,v2i,v2f){
var geometry = new THREE.Geometry();
var mI=new THREE.Vector3((v1f.x+v1i.x)/2,(v1f.y+v1i.y)/2,(v1f.z+v1i.z)/2);
var mF=new THREE.Vector3((v2f.x+v2i.x)/2,(v2f.y+v2i.y)/2,(v2f.z+v2i.z)/2);
var m=new THREE.Vector3((mF.x+mI.x)/2,(mF.y+mI.y)/2,(mF.z+mI.z)/2);
var b=new THREE.Vector3(v2f.x-v2i.x,v2f.y-v2i.y,v2f.z-v2i.z);
var a=new THREE.Vector3(mF.x-mI.x,mF.y-mI.y,mF.z-mI.z);
var p=cross(a,b);
var plan=new THREE.Mesh(new THREE.PlaneBufferGeometry(mF.sub(mI).length(),b.length(),1,1), new THREE.MeshPhongMaterial({color:'yellow'}));

plan.material.side = THREE.DoubleSide;
plan.position.x=m.x;
plan.position.y=m.y;
plan.position.z=m.z;

var v = plan.position.clone();
v.add(p);
plan.lookAt( v );
return(plan);
}
function dibujarLinea(u,v,col){
var L = new THREE.Geometry();
    L.vertices.push(u);
    L.vertices.push(v);
scene.add(new THREE.Line(L, new THREE.LineBasicMaterial({color: col})));
}
function getDistancia(x1,y1,z1,x2,y2,z2){
return Math.sqrt(Math.pow(z2-z1,2)+Math.pow(y2-y1,2)+Math.pow(x2-x1,2));
}
function getBoundingBox(mesh){
var box = new THREE.Box3().setFromObject(mesh);
var tam=getDistancia(box.min.x,box.min.y,box.min.z,box.max.x,box.max.y,box.max.z);
tam/=Math.sqrt(2);
var boxP=new THREE.Mesh(new THREE.BoxGeometry( tam, tam, tam),new THREE.MeshLambertMaterial({color: 'blue'}));
boxP.position.x=mesh.position.x;
boxP.position.y=mesh.position.y;
boxP.position.z=mesh.position.z;
return boxP;
}
function seHizoLaLuz(){
	hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
	hemiLight.color.setHSL( 0.6, 1, 0.6 );
	hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
	hemiLight.position.set( 0, 500, 0 );
	scene.add( hemiLight );
}
function seHizoElSol(){
dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
dirLight.color.setHSL( 0.1, 1, 0.95 );
dirLight.position.set( -1, 1.75, 1 );
dirLight.position.multiplyScalar( 50 );
scene.add( dirLight );

dirLight.castShadow = true;

dirLight.shadowMapWidth = 2048;
dirLight.shadowMapHeight = 2048;

var d = 50;
dirLight.shadowCameraLeft = -d;
dirLight.shadowCameraRight = d;
dirLight.shadowCameraTop = d;
dirLight.shadowCameraBottom = -d;

dirLight.shadowCameraFar = 3500;
dirLight.shadowBias = -0.0001;
dirLight.shadowDarkness = 0.35;
}

function seHizoElFoco(){
light = new THREE.SpotLight( 0xffffff, 1 );
light.castShadow = true;
light.shadowDarkness = 1;
light.shadowCameraRight     =  10;
light.shadowCameraLeft     = -10;
light.shadowCameraTop      =  10;
light.shadowCameraBottom   = -10;
light.position.y=4;
scene.add(light);
}
function createSphere(x,y,z,color){
var sphere = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshPhongMaterial({color: color}) );
sphere.position.x=x;
sphere.position.y=y;
sphere.position.z=z;
scene.add(sphere);
}
	</script>
	</body>
</html>